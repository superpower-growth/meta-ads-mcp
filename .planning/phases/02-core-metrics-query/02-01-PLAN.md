---
phase: 02-core-metrics-query
plan: 01
type: execute
---

<objective>
Build MetricsService abstraction layer for Meta Insights API queries with proper error handling and response parsing.

Purpose: Create a reusable service layer that wraps the Meta SDK's getInsights() method, handles pagination, parses complex response structures (arrays, action types), and provides clean interfaces for MCP tools.

Output: MetricsService module with methods for querying insights at different aggregation levels, complete error handling for attribution window deprecation and rate limits, and utility functions for parsing video metrics and ROAS data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-metrics-query/DISCOVERY.md

# Key files from Phase 1
@src/meta/client.ts
@src/config/env.ts
@src/lib/validation.ts

**Tech stack available:** facebook-nodejs-business-sdk@24.0.1, @modelcontextprotocol/sdk@1.25.3, zod@4.3.6, typescript@5.9.3, tsx

**Established patterns:**
- Directory structure: src/{meta,tools,lib,config}
- Environment configuration via .env with validation
- Error handling with formatted user messages

**Constraining decisions:**
- Phase 1: API version v24.0 (determined by SDK version)
- Phase 1: Zod for all validation
- DISCOVERY.md: Must handle deprecated attribution windows (silent failures as of Jan 12, 2026)
- DISCOVERY.md: Video metrics and actions return arrays, not single values
- DISCOVERY.md: Large queries require async jobs with polling

**Issues being addressed:** None
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MetricsService with insights query foundation</name>
  <files>src/meta/metrics.ts</files>
  <action>
Create MetricsService class that wraps Meta SDK's getInsights() method.

Implementation requirements:
- Import AdAccount, Campaign, AdSet, Ad from facebook-nodejs-business-sdk
- Accept accountId in constructor (format: 'act_XXXXXXXX')
- Implement getAccountInsights(fields, params) method that calls AdAccount.getInsights()
- Return type should be properly typed for insights response
- Add JSDoc comments explaining each method's purpose

Critical patterns from DISCOVERY.md:
- Use getInsights(fields, params) where fields is string[] and params is object
- Common params: {date_preset, level, time_increment, limit}
- Response is array of insight objects with date_start, date_stop, and requested metrics
- DO NOT use deprecated attribution windows (action_attribution_windows) - will return empty data silently

Error handling:
- Wrap SDK calls in try-catch
- Transform Meta API errors into readable messages
- Log raw error codes for debugging

Why this approach: DISCOVERY.md Section "SDK Implementation" shows this is the standard pattern. Avoiding hand-rolled HTTP calls because SDK handles rate limits and auth automatically.
  </action>
  <verify>npm run type-check passes with no TypeScript errors for src/meta/metrics.ts</verify>
  <done>MetricsService class exists with getAccountInsights method, proper TypeScript types, error handling wrapper, and JSDoc documentation</done>
</task>

<task type="auto">
  <name>Task 2: Add response parsing utilities for complex fields</name>
  <files>src/meta/metrics.ts, src/lib/parsers.ts</files>
  <action>
Create parsing utility functions to handle Meta's complex response structures.

In src/lib/parsers.ts, implement:

1. parseActions(actions: any[]): Record<string, number>
   - Input: actions array like [{action_type: 'purchase', value: '42'}, ...]
   - Output: {'purchase': 42, 'link_click': 18}
   - Handle missing/null arrays (return empty object)
   - Convert string values to numbers

2. parseVideoMetrics(insight: any): VideoMetrics
   - Extract video_p25/p50/p75/p95/p100_watched_actions
   - Each is an array, extract first element's value
   - Return {p25: number, p50: number, p75: number, p95: number, p100: number}
   - Handle missing metrics (default to 0)

3. parseRoas(insight: any): RoasMetrics
   - Extract purchase_roas, website_purchase_roas, mobile_app_purchase_roas
   - Each may be array or single value (Meta API inconsistency)
   - Return {purchase: number, website: number, mobileApp: number}
   - Default to 0 for missing values

Define TypeScript interfaces VideoMetrics and RoasMetrics.

Add unit tests would be ideal but skip for now (will add in future TDD phase).

Why this approach: DISCOVERY.md "Complex Action Fields" and "Video Completion Metrics" sections show these fields return arrays that must be parsed. Creating reusable utilities prevents duplicate parsing logic across multiple tools.

What to avoid: Don't assume single values - always check if array. Don't fail on missing metrics - video metrics only exist for video ads.
  </action>
  <verify>npm run type-check passes, parsers.ts exports all three functions with proper TypeScript types</verify>
  <done>Three parsing functions implemented with TypeScript interfaces, handle arrays and missing values gracefully, type-safe exports available</done>
</task>

<task type="auto">
  <name>Task 3: Add pagination handling to MetricsService</name>
  <files>src/meta/metrics.ts</files>
  <action>
Extend MetricsService with automatic pagination support.

Add method: async getAllInsights(fields, params): Promise<InsightObject[]>
- Calls getAccountInsights() for first page
- Checks response.paging.next for additional pages
- Recursively fetches all pages until paging.next is undefined
- Aggregates all results into single array
- Return complete dataset

Implementation notes from DISCOVERY.md:
- Default limit is 25 records per page
- paging.next contains cursor for next page
- Can set params.limit up to 5000 to reduce pagination rounds
- For >1 year daily data, must use async: true (returns job ID) - NOT implementing async jobs in this task, just documenting limitation

Error handling:
- If any page fails, throw error with page number context
- Don't retry automatically (phase 9 will add retry logic)
- Log warning if dataset is very large (>1000 records)

Add JSDoc warning: "For queries spanning >1 year with daily data, use async jobs instead (not yet implemented)"

Why separate from basic method: Some queries need single page (recent data), others need full dataset (historical analysis). Giving tools both options.
  </action>
  <verify>npm run type-check passes, getAllInsights method exists with proper async typing</verify>
  <done>Pagination implemented with getAllInsights method, handles paging.next cursor, aggregates multi-page results, includes documentation warnings about async job limitations</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run type-check succeeds with no TypeScript errors
- [ ] src/meta/metrics.ts exports MetricsService class
- [ ] src/lib/parsers.ts exports parseActions, parseVideoMetrics, parseRoas functions
- [ ] All functions have JSDoc documentation
- [ ] No runtime dependencies added (using existing SDK)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- MetricsService provides clean abstraction over Meta SDK
- Response parsers handle complex array structures
- Pagination support ready for large datasets
- No TypeScript errors introduced
- Code follows established patterns from Phase 1
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-metrics-query/02-01-SUMMARY.md`:

# Phase 2 Plan 01: MetricsService Foundation Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Deviations from Plan

[Any deviations using the 3-rule classification system, or "None"]

## Next Phase Readiness

Ready for 02-02-PLAN.md (Campaign Performance MCP Tool)

## Verification Checklist

- [ ] All verification items from plan
</output>
