---
phase: 02-core-metrics-query
plan: 02
type: execute
---

<objective>
Create user-facing MCP tool for querying campaign performance metrics through conversational interface.

Purpose: Expose Meta Insights API capabilities through an MCP tool that Claude can call to retrieve CTR, CPC, ROAS, and video completion metrics for campaigns with natural language date ranges and proper validation.

Output: get-campaign-performance MCP tool with Zod schema validation, date range parsing, metric formatting for Claude consumption, and integration into MCP server tool registry.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-core-metrics-query/DISCOVERY.md
@.planning/phases/02-core-metrics-query/02-01-SUMMARY.md

# Key files from Phase 1
@src/tools/index.ts
@src/tools/get-account.ts
@src/index.ts
@src/lib/validation.ts

# New files from Plan 02-01
@src/meta/metrics.ts
@src/lib/parsers.ts

**Tech stack available:** facebook-nodejs-business-sdk@24.0.1, @modelcontextprotocol/sdk@1.25.3, zod@4.3.6, MetricsService from 02-01

**Established patterns:**
- Tool structure: export tool definition + implementation function
- Tool registry in src/tools/index.ts
- Zod validation via createToolSchema helper
- Error handling returns formatted strings

**Constraining decisions:**
- Phase 1: Tool handler pattern with separate files
- Phase 1: Zod for all validation
- Plan 02-01: MetricsService provides insights query abstraction
- Plan 02-01: Parser utilities handle complex response fields
- DISCOVERY.md: Date presets are 'last_7d', 'last_30d', etc (string values)
- DISCOVERY.md: Must request specific fields, no defaults

**Issues being addressed:** None
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create get-campaign-performance tool definition and validation</name>
  <files>src/tools/get-campaign-performance.ts</files>
  <action>
Create MCP tool for querying campaign performance metrics.

Tool definition structure (following get-account.ts pattern):

1. Define Zod schema for input validation:
```typescript
const schema = z.object({
  dateRange: z.enum(['last_7d', 'last_30d', 'last_90d', 'this_month']).default('last_7d'),
  campaignId: z.string().optional(),
  metrics: z.array(z.enum(['impressions', 'clicks', 'spend', 'ctr', 'cpc', 'cpm', 'purchase_roas'])).default(['impressions', 'clicks', 'spend', 'ctr', 'cpc'])
});
```

2. Export tool definition:
```typescript
export const getCampaignPerformanceTool: Tool = {
  name: 'get-campaign-performance',
  description: 'Query campaign performance metrics including CTR, CPC, ROAS, and basic video completion rates for a specified date range',
  inputSchema: zodToJsonSchema(schema)
};
```

3. Export implementation function:
```typescript
export async function getCampaignPerformance(args: unknown): Promise<string>
```

Implementation details:
- Validate args with schema.parse() (will throw if invalid)
- Import MetricsService from src/meta/metrics.ts
- Get accountId from env.ts config
- Instantiate MetricsService with accountId
- Call appropriate method based on whether campaignId is provided
- If campaignId: query that specific campaign
- If no campaignId: query at account level with level='campaign' to get all campaigns
- Use date_preset from dateRange parameter
- Request fields from metrics parameter

Return format: JSON stringified array of campaign metrics, or formatted error message.

What to avoid: Don't hard-code metric fields (use user's metrics array). Don't assume campaignId is always provided. Don't fetch video metrics yet (that's Phase 3).

Why this approach: Following established tool pattern from get-account.ts. DISCOVERY.md shows level='campaign' returns all campaigns when querying from account level.
  </action>
  <verify>npm run type-check passes, tool file exports both tool definition and implementation function</verify>
  <done>Tool definition created with Zod schema, implementation function signature defined, proper imports from MetricsService and parsers, follows Phase 1 tool patterns</done>
</task>

<task type="auto">
  <name>Task 2: Implement campaign performance query logic</name>
  <files>src/tools/get-campaign-performance.ts</files>
  <action>
Complete the implementation of getCampaignPerformance function.

Query logic:
1. Initialize MetricsService with account ID from env config
2. Prepare params object:
   ```typescript
   const params = {
     date_preset: args.dateRange,
     level: 'campaign',
     time_increment: 'all_days'  // Single result per campaign
   };
   ```
3. Call MetricsService.getAccountInsights(args.metrics, params)
4. If campaignId provided: filter results to matching campaign
5. For each insight result, parse response:
   - Extract basic metrics (impressions, clicks, spend, ctr, cpc, cpm)
   - If purchase_roas requested, use parseRoas() from parsers.ts
   - Include campaign_id, campaign_name, date_start, date_stop
6. Format as readable JSON structure:
   ```json
   {
     "dateRange": "last_7d",
     "campaigns": [
       {
         "id": "...",
         "name": "...",
         "period": "2026-01-24 to 2026-01-31",
         "metrics": {
           "impressions": 12500,
           "clicks": 342,
           "spend": 145.67,
           "ctr": 2.74,
           "cpc": 0.43
         }
       }
     ]
   }
   ```
7. Return JSON.stringify(result, null, 2) for readable output

Error handling:
- Catch MetricsService errors and return formatted message
- If no campaigns found, return "No campaigns found for date range"
- If campaignId specified but not found, return "Campaign {id} not found"

Testing approach: After implementation, manual test with npm run dev and MCP inspector.

Why this format: Claude can easily parse JSON, and pretty-printing (null, 2) makes conversational responses readable.

What to avoid: Don't return raw SDK response objects (contain internal SDK properties). Don't include all fields (only requested metrics). Don't fail if optional ROAS is missing (video ads may not have purchase data).
  </action>
  <verify>npm run build succeeds, implementation handles all code paths (with/without campaignId, with/without ROAS metrics)</verify>
  <done>Query logic implemented, response formatting complete, error cases handled, returns pretty-printed JSON suitable for Claude consumption</done>
</task>

<task type="auto">
  <name>Task 3: Register tool in MCP server</name>
  <files>src/tools/index.ts, src/index.ts</files>
  <action>
Integrate get-campaign-performance tool into MCP server.

In src/tools/index.ts:
1. Import getCampaignPerformanceTool from './get-campaign-performance.js'
2. Add to tools array: export const tools: Tool[] = [getAccountTool, getCampaignPerformanceTool];

In src/index.ts:
1. Import getCampaignPerformance function from './tools/get-campaign-performance.js'
2. Add case to CallToolRequestSchema handler:
   ```typescript
   case 'get-campaign-performance': {
     const result = await getCampaignPerformance(args as any);
     return {
       content: [{ type: 'text', text: result }]
     };
   }
   ```

Follow exact pattern from existing get-account tool case.

Verification after changes:
- npm run build succeeds
- npm run dev starts without errors
- Server logs "Meta Ads MCP server started successfully"

Why this pattern: Maintains consistency with Phase 1 tool registration. Tool registry pattern allows easy discovery via tools/list, and switch statement provides type-safe routing.

What to avoid: Don't forget .js extension in imports (ES modules require explicit extensions). Don't modify existing tool cases.
  </action>
  <verify>npm run build && npm run dev starts successfully, no TypeScript errors, server initializes without crashes</verify>
  <done>Tool registered in tools array, handler added to CallToolRequestSchema switch statement, server starts successfully, tool discoverable via MCP protocol</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds with no TypeScript errors
- [ ] npm run dev starts server without crashes
- [ ] Tool appears in tools registry (2 tools total)
- [ ] Manual test with MCP inspector shows tool listed
- [ ] Sample query returns formatted JSON response (can test with mock data if needed)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- get-campaign-performance tool accessible via MCP protocol
- Returns properly formatted JSON with campaign metrics
- Handles date ranges and optional campaign filtering
- Error messages are user-friendly for Claude
- No TypeScript errors or runtime crashes
- Phase 2 complete: Core metrics queryable through MCP
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-metrics-query/02-02-SUMMARY.md`:

# Phase 2 Plan 02: Campaign Performance MCP Tool Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description
- `path/to/another.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Deviations from Plan

[Any deviations using the 3-rule classification system, or "None"]

## Next Phase Readiness

Phase 2 complete. Ready for Phase 3: Video Analytics (video-specific breakdowns and demographics).

Recommendations for Phase 3:
- Extend MetricsService with breakdown support (age, gender, video_type)
- Create dedicated video analytics tool separate from campaign performance
- Use parseVideoMetrics() from parsers.ts for percentile data

## Verification Checklist

- [ ] All verification items from plan
</output>
